from sys import exception
from types import new_class

print("python lecture 10!!!!!!!!!!!!!!!!")
#  built in ფუნქციები
# შეგვიძლია ფუნქციები მივანიჭოთ ცვლადებს
def add(x, y):
    return x + y
# შევქმენით add() ფუნქცია
result = add(1, 2)
# result ცვლადს გადავეცით add ფუნქცია
print(result)


# შესაძლებელია ფუნქციას გადავცეთ ფუნქციაც
def func_in_func(func, a, b, c):
    return func(a, b)
# შევქმენით ფუნქცია სახელად "ფუქნცია ფუქნციაში"
# რომესაც დავაბრუნებინეთ ფუნქცია რომელლსაც გადაეცემა a და b პარამტერი
def add(x, y):
    return x + y
print(func_in_func(add, 2, 3, 5))
# შევქმენთ ახალი ფუნქცია სახელად add(),
# პირველ შექმნილ ფუნქციას გადავეცით სამი პარამეტრი რომელიც მნიშვნელობად მიიღებს 3 არგუმენტს
# მის გამოძახებისას პირველ არგუუმენტად გადავეცით add() ფუქნცია, რომელიც შეასრულებს იმას რაც add() ფუქნციისთვის გავქვს გაწერილი
# ამ შემთხვევაში მიმატება
# სამი პარამეტრიდან :3
# 1 - არგუმენტად მიიღებს ფუნქციას
# add() ფუნქციას სჭირდება 2 არგუმენტი x და y პარამეტრებისთვის
# 1 - x მა არგუმენტად მიიღო a პარამეტრი
# 2 - y მა არგუმენტად მიიღო ბ პარამეტრი
# a - არგუმენტად მიიღებს ჩვენს მიერ გადაცემულ არგუმენტს და იგივე გადაეცემა xსაც
# b - არგუმენტად მიიღებს ჩვენს მიერ გადაცემულ არგუმენტს და იგივე გადაეცემა yსაც






# ფუნქციაში ფუნქციიიის დაბრუნება
def get_multiplier(x):
    def multiplier(y):
        return x * y
    return multiplier

def multiplier(x):
    def got_multiplier(y):
        return x * y
    return got_multiplier
# ფუქნცია აბრუნებს ორი არგუმენტისთვის გადაცემული პარამეტრების ნამრავლს
# მაგრამ მათთვის არ გადაგვიცია არგუმენტები
# როგორც გავიერეთ შეგვიძლია ფუქნცია გადავცეთ ცვლადს
# იმისათვის რომ დინამიური ფუქნცია შემვქმნათ, უმჯობესია რომ გამოძახებისას დავაბრუნოთ მხოლოდ ფუქნცია და არ გადაცვცეთ არგუმენტები
get_multiplier_by_5 = get_multiplier(6)
# ახალ ცვალდი შევქმენით რომელსაც გავუტოლეთ ფუქნცია, ფუნქცია აბრუნებს ორი რიცხვის ჯამს
print(get_multiplier_by_5(6))
# ცვლადს უნდა გავუტოლთ გარე ფუქბცუა და არა შიდა ფუნქცია
# მთავარ ფუქნცას არგუმენტი უნდა გადავცეთ გატოლებისასვე
# x = function(6) ფრჩხიელბში გადაეცემა მას არგუმენტი
# ხოლო ცვლადის გამოძახებისას გადაეცემა შიდა ფუნქციის პარამეტრს არგუმენტი


# # რეკურსია!!!!!!!!!!!!!!!!!!!!!!!!!!1
# # ფუნქცია რომელიც იძახებს თავის თავს
# # ფუნქციის ფუნქციაში გამოსაძახებელი ტექნიკა, რაღაც პრობლემის გადასაჭრელად
# def fuctorial(n):
#     if n ==0 or n == 1:
#         return n
#     else:
#         return n * fuctorial(n - 1)
# print(fuctorial(int(input("enter a number: "))))# fuctorial() ფუნქცია გამოვიყენეთ ფუნქციაშივე რათა პრობლემა გადაგვეჭრა
# # return ში გამოვიძახეთ თავისი თავი
# # რეკურის მუშაობს ისევე როგორც ციკლი: fuctorial() ფუქნციაში, პირობა გადავეცით რომ თუკი n 0 ან 1 ის ტოლი არ იქნება,
# # უსასრულოდ უნდა იმუშაოს: >>>
# # "მაგ, n=5 / ამ შემთხვევაში, მანამ სანამ არ გაუტოლდება n არ გაუტილდება 1ს ან 0ს,
# # უსუსრულოდ დააკლდება n-1, ჯერ გახდება 5 > 4 > 3 > 2 > 1, ბოლოს როცა 1ს გატოლდება, რეკურისა შეწყვტს მუშაობას "
# # ორი პირეობაა საჭირო
# # 1: bace-case რომელიც გულისხმობს შეწყვეტის პირობას, ამ შემთხვევაში n=1or0
# # 2: recursive-case რომელიც გულისხმობს თვისი თავის გამოძახებისას nით შემცირების/გაზრის სანამ ფუქნცია არ გაუტოლდება bace-case პირობას
# def n(num):
#     if num == -1:
#         return num
#     else:
#         return num * n(num - 1)
# print(n(int(input("enter a number: "))))
# # base-case ამ ფუნქციაში არის ის რომ num უნდა გაუტოლდეს -1(მინუს ერთს)
# # recursive-case კი არის ის რომ num უნდა დააგკლდეს 1, ყოველ რეკურსიაზე სანამ ციფრი არ გაუტოლდება -1(მინუს 1ს)
# # თუ მინუსის (-) ნაცვლად გავუწერდი პლიუსს (+), რეკურსია არასდროს გაუტოლდება მინუს 1ს(-1), ამ შემთხვევაში გავა ერორზე
# # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# # მაგრამ, შესაძლოა ფუნქციამ უსუსრულოდ გამოიძახებს თავისი თავი, ამისთვის მას უნდა გადავცეთ პირობა სად უნდა შეწყდეს რეკურსია
# # def recursia():
#
#
# # რეკურსიული ფუნქცია
# def n(num):
#     if num == -1:
#         return num
#     else:
#         return num * n(num - 1)
# print(n(int(input("enter a number: "))))
# # პირველი არის რეკურსიუსი რაც იმას ნიშნავს რომ ციკლურად იმოქმედებს
#
#
# # არარეკურსიული ფუნქცია:
# def n(num):
#     if num == -1:
#         return num
#     else:
#         return num * (num - 1)
# print(n(int(input("enter a number: "))))
# მეორე არაა რეკურსიული / განსხვავაება ისაა რომ პირველში გამოვიძახეთ ფუქნცია ხოლო მეორეში კი გამოვიძახეთ მათემატიკური ფუნქცია
# nums გამოაკლდება 1 და გამრავლდება numზე






# lambda - ანონიმური ფუნქციები!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# უსახელო ფუნქციები,
# ლამბდა ფუნქციები იემნება lambda სიტყვით
# როცა დიდი ლოგიკების დაწერა არაა საჭირო მჯობესია lambda ფუქნცეიბი შევქმნათ
# ან სწრაფად შევქნათ ფუნქცია, რომელსაც ხშირად არ გამოვიყენებთ
# higher order functions თან, რომელიც ითხოვს ფუნქციის გადაცემს > უმჯობესია lambda ფუნქციის შექმნა
# syntax = ცვლადს ვუტოლებთ lambda საკვანძო სიტყვა და პარამეტრი უნდა გადავცეთ
# return არ გააჩნია lambda ფუქნცია, ამას აკეთებს : ორი წერტილი
# :ორი წერტილი არნიშნავს returnს
test = lambda x:x
print(test(5))
# :ორმა წერტილმა დააბრუნდა x პარამეტრი
# print()ით დავბეჭდეთ ცვლადი რომელშიც შენახულია ფუნქცია
# შესაძლებელია გადავცეთ ორი და მეტი პარამეტრი

lamd = lambda x=7, y=7 : x + y
print(lamd(x=7))






# map() ფუნქცია
# map() ფუნქციას გადაეცემა ორი პარამეტრი(ფუნქცია, და მეორე პარამეტრი)
# მეორე პარამეტრად უნდა გადაეცეს იტერირებადი ელემენტი
def my_func(n):
    return len(n)

names_list = ["malkhaz", "nika", "lasha", "ika", "luka"]

lens = map(my_func, names_list)
print(list(lens))
# map() ფუქნცია გადაუვლის გადაცემულ იტერირებად ცვლადს, გადაცემული ფუნქციის მიხედვით
# მაგ: my_func გვიბრუნებს ელემენტების სიგრძეს
# lensცვლადს გადავეცით map() ით ე ფუნქცია, და მას გადავეცით ლისტი აგრეთვე
# map() უქნციის საშუალებით, my_func ფუქნცია გადაუვლის name_listის ელემენტებს და გამოიტანს მათ სიგრძეს


# def new_func(n):
#     return n + n
# ცაკლე ფუნქცია რომ არ შევქმნათ, შეგვიძლია map()ში შევქმანთ lambda: ფუქნცია
num_list = [1, 3, 4, 56, 76, 32, 12]
result = map(lambda n:n + n , num_list)
print(tuple(result))
# აქაც new_func აბრუნებს რიცხვების ჯამს
# ლისტებში არებულ რიცხვებს იგი მიუმატებს თავიდან თავს და ისე დააბრუნებს პასუხს num_list[0] + num_list[0]
# მეორე იტერაციაზე num_list[1] + num_list[1]
names_list = ["malkhaz", "nika", "lasha", "ika", "shako", "luka"]
# სახელების პირველი ასოების მაღალ რესსტრში გადაყვანა
capitalized_names = map(lambda n: n.capitalize(), names_list)
print(list(capitalized_names))







# filter() ფუქნცია!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
names_list = ["malkhaz", "nikaaa", "lasha", "ika", "shako", "luka"]
more_than_5_sylable = filter(lambda n: len(n) > 5, names_list)
print(list(more_than_5_sylable))
# მსგავსად map() ფუქნციისა გადაეცემა ორი პარამეტრი/ 1-ფუნქცია და 2-იტერირებადი ელემენტი
# როგორც map() ასევე filter() იც ელემენტებს გადაუვლის გადაცემული ფუნქციის მიხედვით და დააბრუნებს გადაცემული ფუნქციის ლოგიკის მიხედვით
# ცვლადს გადავეცით filter() ფუქნცია, რომელშიც გადავეცით ორი პარამეტრი 1 lamdba ფუქნცია რომელიც აბრუნებს მხოლოდ იმ ელემენტებს რომელთა სიგრძე 5ზე მეტია
# მეორე პარამეტრად გადავეცით name_list, რომლებსაც გადაახარისხებს და დააბრუნებს იმ სახელებს რომლებიც 5ზე მეტი მარცვლისაგან შედგებიან









# zip() ფუნქცია ორი იტერირებადი პარამეტრი გადაეცემა და ორ პარამეტს აერთიანებს ტაპლის სახით
names_list = ["malkhaz", "nikaaa", "lasha", "ika", "shako", "luka", "toro"]

age_list = [22, 24, 25, 27, 30, 13, 28]

person_name_age = zip(names_list, age_list)
print(list(person_name_age))
# რიგითობის მიხედვით გააერთაიანა ტაპლის სახით
# თ რაოდენობა არ დაემთხვა, მაგ: 4 სახელი და 6 ასაკი, 4 სახელს გაუტოლებს პირველ 4 ასაკს და მათ დააბრუნებს,
# თუ პირიქით მაშინ პირველ 4 ასაკს გაუტოლა პირველი 4 სახელი
# რაოდენობის და რიგითობის მიხედვით შეუსაბამებს ერთმანეთს ელემენტებს
# დარჩენილს კი გააქრობს და აღარ გამოიტანს








# reduce() ფუქნცია გადაცემულ ელემენტები დაყავს ერთ საბოლოო მნიშვნელობამდე
# გადაეცემა ორი პარამეტრი
# 1: ფუნქცია, რომლის მიხედვითაც დაიყვანს რიცხვებს საბოლოო მნიშვნელობამდე
# 2: იტერირებადი ობიექტი
from functools import reduce
# reduce() ფუქნცია უნდა დავაიმპორტოთ რადგანაც იგი მოდულია
numbers = [12, 32, 43, 34, 23, 54, 76, 4, 98, 46, 10]
print(reduce(lambda x, y: x + y, numbers))
# გადავეცით lambda ფუქნცია რომელიც აბრუნებს ორი რიცხვის ჯამს
# მეორე გადავეცით იტერირებადი ელემენტი
# მიუხედავად იმისა რომ 2ზე მეტი რიცხვი გავქვს ლისტში, reduce() ფუქნცია ჯერ გაუტოლდება პირველ ორ რიცხვს,
# შემდგომ დააჯამებს და მათი ჯამი გახდება ერთი მნიშვნოლობა, მეორე რიცვხად წამოიღებს იგი მესამე რიცხვს და ა. შ გაუყვება მანამ სანამ






# error!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# ერორებზე მუშაობა
# try/except მეთოდი გვეხმარება რომ დავიჭიროთ ერორები
# იმისათვის რომ errorმა კოდის მუშაობა არ არიოს შეგვიძლია ერორები დავიჭიროთ და ერორზე გასვლის ნაცვლად დავაბრუნებინოთ ერორი
# მას გააჩნია 4 ბლოკი
# 1 - try
# 2 - except
# 3 - else
# 4 - finally
# try ში იწერება კოდი უშუალოდ
# except ში ვწერთ იმას რაც გვინდა რომ დავაბრუნებინოთ იმ შემთხვევაში თუ კოდი ერორზე გავა
# else ში ვწერთ უკვე იმას რაც კოდმა გვინდა რომ დააბრუნოს
# finally ში კი კოდი ბრუნდება, მიუხედავად იმისა გავა თუ არა ერორზე კოდი finally ყველავარიანტში შესრულდება
# else და except შორის კი ერთ ერთი შესრულდება
try:
    num1 = int(input("Enter a number: "))
    num2 = int(input("Enter a number: "))
    result = num1 / num2
# როგორც ვიცით გვაქვს რამდენი სახის ერორი პითონში: valueerror, typeerror, და ა შ
# შეგვიძლია თითოეული ტიპის ერორისთვის სხვადასხვა რამ დავაბრუნებინოთ
# except: მოიცავს ყველა სახის ერორს
# exceot errorname : თუ except შემდგომ დავუწერთ errorname-ს მაშინ ეს except მხოლოდ იმ კონკრეტულ ერორს შეეხება რომელიც გვიწერია exceptის შემდეგ

except ValueError:
    print("please inset only integers")
# ეს ერორი მხოლოდ valueerrorsს შეეხება, ანუ თუკი არასოწრი მნიშვნელობა გადაცევით


except ZeroDivisionError:
    print("can't divide by zero")
# ეს ერორი ეხება მხოლოდ იმ შემთვევას თუკი ნულზე ვყოფთ

# აგრეთვე გვაქვს Exception as e
except Exception as e:
    print(e)
# ეს e მნიშვნელობად იღებს იმ ერორს რომელზეც კოდი გავა
# თუკი ეს იქნება typeerror მნიშვნელობა მიიღებს typeerrorის ერორს

except:
    print("something went wrong")
# ეს ერორი ეხელა ყველა შემთხვევას, მაგრამ რადგანაც წინ გვიწერია კონკრეტული ერორებისთვის except, ამ ორი ერორის გარდა ყვეა ერორს შეეხება

else:
    print(result)
finally:
    print("end of a program")

































#
# # მოცემულია პროდუქტების ლისტი:
#
# products = [
#     {"name": "Laptop", "price": 1200},
#     {"name": "Mouse", "price": 15},
#     {"name": "Keyboard", "price": 25},
#     {"name": "Monitor", "price": 150},
#     {"name": "Power", "price": 100},
#     {"name": "Pad", "price": 10},
# ]
#
# # filter() ფუნქციის გამოყენებით გაფილტრეთ და გამოიტანეთ პროდუქტები, რომლის ფასი ნაკლებია 100-ზე;
# # map() ფუნქციის გამოყენებით გამოიტანეთ ყველა პროდუქტის სახელი და ფასი
# # sorted() ფუნქციის გამოყენებით დაასორტირეთ პროდუქტების სია ფასის მიხედვით
# # reduce() ფუნქციის გამოყენებით გამოიტანეთ ყველა პროდუქტის ფასების ჯამი
# # if products[price]
# def price(n):
#     return n < 100
















#
#
# lst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# ls = list(filter(lambda x : x > 6, lst))
# print(ls)




# # გამოიყენეთ lambda ფუნქცია sorted() ფუნქციაში, იმისათვის რომ
# # დაასორტიროს მოცემული ლისტი: [(1, 3), (4, 2), (2, 5)] - მასში
# # არსებული ელემენტების მეორე ელემენტის მიხედვით
# lst = [(1, 3), (4, 2), (2, 5), (31, 1), (3, 8), (3, 7)]
# new_lst = list(sorted(lst, key=lambda x : x[1]))
# print(new_lst)






def f(n):
    if n ==0 or n == 1:
        return n
    else:
        return n * f(n - 1)
print(f(int(input("Enter a number: "))))

















































